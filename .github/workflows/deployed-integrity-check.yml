name: Deployed Integrity Check
on:
  schedule:
    - cron: '15 * * * *'  # hourly + 15 min offset
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  id-token: write
  packages: write

jobs:
  integrity:
    strategy:
      matrix:
        predicate_version: [v1, v2]
    runs-on: ubuntu-latest
    env:
      NODE_VERSION: '20'
      TARGET_URL: https://www.humanaiconvention.com/
      COSIGN_VERSION: v2.4.0
      PREDICATE_VERSION: ${{ matrix.predicate_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Fetch Fulcio Certificate Chain (fail-fast + enforce root)
        run: |
          set -euo pipefail
          mkdir -p fulcio-chain
            curl -sSfL https://fulcio.sigstore.dev/api/v2/rootCert -o fulcio-chain/root.pem
            curl -sSfL https://fulcio.sigstore.dev/api/v2/intermediateCert -o fulcio-chain/intermediate.pem
            cat fulcio-chain/root.pem fulcio-chain/intermediate.pem > fulcio-chain/fulcio-chain.pem
            root_hash=$(sha256sum fulcio-chain/root.pem | cut -d ' ' -f1)
            echo "Fulcio root sha256=$root_hash"
            if [ -f .github/fulcio-root.expected.json ]; then
              expected=$(jq -r '.sha256' .github/fulcio-root.expected.json)
              if [ -n "$expected" ] && [ "$expected" != "$root_hash" ]; then
                echo "::error::Fulcio root hash mismatch (expected $expected got $root_hash). Enforcing failure." >&2
                if [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
                  title="Fulcio Root Rotation (ENFORCED FAIL)"
                  body="Observed Fulcio root hash $root_hash differs from expected $expected. Workflow is failing to prevent unreviewed trust root change. If rotation is legitimate: 1) Obtain new Fulcio root, 2) Verify via trusted channel, 3) Update .github/fulcio-root.expected.json in a reviewed PR, 4) Re-run workflow."
                  curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github+json" \
                    -X POST -d "$(jq -n --arg t "$title" --arg b "$body" '{title:$t, body:$b, labels:["supply-chain","audit","fulcio-root-rotation"]}')" \
                    "https://api.github.com/repos/$GITHUB_REPOSITORY/issues" >/dev/null || true
                fi
                exit 42
              fi
            fi
            echo "Fulcio chain assembled:"; ls -l fulcio-chain
      - name: Setup Node
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v5.0.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
      - name: Install (workspace web only)
        run: |
          npm --workspace web ci || (cd web && npm install)
      - name: Generate CycloneDX SBOM (web workspace)
        run: |
          set -euo pipefail
          if [ -f web/package.json ]; then
            npx --yes @cyclonedx/cyclonedx-npm@3.11.5 --output-format json --output-file sbom.json --spec-version 1.5 --omit dev --package-lock-only || \
              echo "SBOM generation (prod only) failed, retrying including dev";
            if [ ! -f sbom.json ]; then
              npx --yes @cyclonedx/cyclonedx-npm@3.11.5 --output-format json --output-file sbom.json --spec-version 1.5 || echo "SBOM generation failed"; fi
            if [ -f sbom.json ]; then jq '.metadata.tools |= . + [{vendor:"cyclonedx-npm", name:"@cyclonedx/cyclonedx-npm", version:"3.11.5"}]' sbom.json > sbom.tmp && mv sbom.tmp sbom.json; fi
          else
            echo "No web/package.json present; skipping SBOM"; fi
      - name: Run Deployed Integrity Check (baseline)
        id: baseline
        run: |
          node web/scripts/verify-deployed-integrity.mjs --url $TARGET_URL --json --out integrity-report.json --show-index || echo "CHECK_EXIT=$?" >> $GITHUB_ENV
          echo "report_path=integrity-report.json" >> $GITHUB_OUTPUT
      - name: Show Report
        run: |
          cat integrity-report.json || true
          jq -r '. | "Match: " + (.match|tostring) + " remote=" + (.remoteSha256 // "null") + " baseline=" + (.baselineSha256 // "null")' integrity-report.json || true
      - name: Sign Integrity Report + Bundle + Predicate
        id: sign
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          digest=$(sha256sum integrity-report.json | cut -d ' ' -f 1)
          echo "digest=$digest" >> $GITHUB_OUTPUT
          ./cosign sign-blob --yes integrity-report.json \
            --bundle integrity-report.json.rekor.json \
            --output-signature integrity-report.json.sig \
            --output-certificate integrity-report.json.pem
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          reportFields=$(jq '{match, baselineSha256, remoteSha256, url, elapsedMs, error}' integrity-report.json)
          pred_type="https://humanaiconvention.com/attestation/integrity-report@${PREDICATE_VERSION}"
          if [ "${PREDICATE_VERSION}" = "v2" ]; then
            jq -n --arg d "$digest" --arg ts "$ts" --argjson rf "$reportFields" --arg pt "$pred_type" '{
              _type: $pt,
              predicateVersion: "2.0",
              subject: [{name: "integrity-report.json", digest: {sha256: $d}}],
              timestamp: $ts,
              description: "Integrity report (v2) for deployed index.html baseline vs remote",
              report: { status: $rf.match, hashes: { baseline: $rf.baselineSha256, remote: $rf.remoteSha256 }, metrics: { elapsedMs: $rf.elapsedMs }, url: $rf.url, error: $rf.error }
            }' > integrity-report.predicate.json
          else
            jq -n --arg d "$digest" --arg ts "$ts" --argjson rf "$reportFields" --arg pt "$pred_type" '{
              _type: $pt,
              subject: [{name: "integrity-report.json", digest: {sha256: $d}}],
              timestamp: $ts,
              description: "Integrity report for deployed index.html including baseline vs remote hash comparison",
              reportFields: $rf
            }' > integrity-report.predicate.json
          fi
          # Validate predicate against version-specific schema
          if [ "${PREDICATE_VERSION}" = "v2" ]; then
            if [ -f .github/schemas/integrity-report-predicate.v2.schema.json ]; then
              npx --yes ajv-cli@5.0.0 validate -s .github/schemas/integrity-report-predicate.v2.schema.json -d integrity-report.predicate.json --strict=false
            else
              echo "Missing v2 schema (.github/schemas/integrity-report-predicate.v2.schema.json)" >&2; exit 1
            fi
          else
            if [ -f .github/schemas/integrity-report-predicate.schema.json ]; then
              npx --yes ajv-cli@5.0.0 validate -s .github/schemas/integrity-report-predicate.schema.json -d integrity-report.predicate.json --strict=false
            else
              echo "Schema missing (.github/schemas/integrity-report-predicate.schema.json); failing" >&2; exit 1
            fi
          fi
          pred_digest=$(sha256sum integrity-report.predicate.json | cut -d ' ' -f 1)
          echo "predicate_digest=$pred_digest" >> $GITHUB_OUTPUT
      - name: Sign Fulcio Chain Blob
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          ./cosign sign-blob --yes fulcio-chain/fulcio-chain.pem \
            --bundle fulcio-chain/fulcio-chain.pem.rekor.json \
            --output-signature fulcio-chain/fulcio-chain.pem.sig \
            --output-certificate fulcio-chain/fulcio-chain.pem.pem
          sha=$(sha256sum fulcio-chain/fulcio-chain.pem | cut -d ' ' -f1)
          echo "chain_sha=$sha" >> $GITHUB_OUTPUT
      - name: Build & Push Integrity Report Image
        id: image
        env:
          IMAGE_NAME: integrity-report
        run: |
          set -euo pipefail
          owner_repo=$(echo "$GITHUB_REPOSITORY" | tr '[:upper:]' '[:lower:]')
          image="ghcr.io/${owner_repo}-${IMAGE_NAME}:${GITHUB_RUN_ID}-${PREDICATE_VERSION}"
          echo "Building image $image"
          mkdir -p ci-image
          cp integrity-report.json ci-image/
          cp fulcio-chain/fulcio-chain.pem ci-image/ || true
          cat > ci-image/Dockerfile <<'EOF'
          FROM scratch
          LABEL org.opencontainers.image.source="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY"
          LABEL org.opencontainers.image.description="Ephemeral integrity report artifact container"
          COPY integrity-report.json /integrity-report.json
          COPY fulcio-chain.pem /fulcio-chain.pem
          EOF
          echo "Logging into GHCR"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
          docker build -t "$image" ci-image
          docker push "$image"
          full_ref=$(docker inspect --format='{{index .RepoDigests 0}}' "$image")
          digest=${full_ref#*@}
          echo "image_ref=$full_ref" >> $GITHUB_OUTPUT
          echo "image_digest=$digest" >> $GITHUB_OUTPUT
          echo "Image pushed: $full_ref"
      - name: Attest Fulcio Chain Predicate
        id: chain_attest
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          chain_sha=$(sha256sum fulcio-chain/fulcio-chain.pem | cut -d ' ' -f1)
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          jq -n --arg sha "$chain_sha" --arg ts "$ts" '{
            _type: "https://humanaiconvention.com/attestation/fulcio-chain@v1",
            subject: [{name: "fulcio-chain.pem", digest: {sha256: $sha}}],
            timestamp: $ts,
            description: "Fulcio root+intermediate chain used for signature verification",
            metadata: { format: "pem+concat" }
          }' > fulcio-chain.predicate.json
          if [ -f .github/schemas/fulcio-chain-predicate.schema.json ]; then
            npx --yes ajv-cli@5.0.0 validate -s .github/schemas/fulcio-chain-predicate.schema.json -d fulcio-chain.predicate.json --strict=false
          fi
          image_ref='${{ steps.image.outputs.image_ref }}'
          ./cosign attest --yes --predicate fulcio-chain.predicate.json --type "https://humanaiconvention.com/attestation/fulcio-chain@v1" "$image_ref"
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/fulcio-chain@v1" "$image_ref" > verify-fulcio-chain-attestation.output 2>&1 || true
      - name: Attest Integrity Predicate
        id: integrity_attest
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          image_ref='${{ steps.image.outputs.image_ref }}'
          predicate_type="https://humanaiconvention.com/attestation/integrity-report@${PREDICATE_VERSION}"
          ./cosign attest --yes --predicate integrity-report.predicate.json --type "$predicate_type" "$image_ref"
          ./cosign verify-attestation --type "$predicate_type" "$image_ref" > verify-attestation.output 2>&1 || true
      - name: Cosign Attest SBOM (if present)
        if: success() && hashFiles('sbom.json') != ''
        id: sbom_attest
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          image_ref='${{ steps.image.outputs.image_ref }}'
          sbom_type="https://humanaiconvention.com/attestation/sbom@v1"
          jq '{bomFormat, specVersion, version, metadata, components}' sbom.json > sbom.min.json || cp sbom.json sbom.min.json
          if [ -f .github/schemas/sbom-min.schema.json ]; then
            echo "Validating SBOM against minimal schema";
            if ! npx --yes ajv-cli@5.0.0 validate -s .github/schemas/sbom-min.schema.json -d sbom.min.json --strict=false; then
              echo "::error::SBOM failed schema validation"; exit 31; fi
          else
            echo "Warning: sbom-min.schema.json not found; skipping validation";
          fi
          ./cosign attest --yes --predicate sbom.min.json --type "$sbom_type" "$image_ref"
          ./cosign verify-attestation --type "$sbom_type" "$image_ref" > verify-sbom-attestation.output 2>&1 || true
      - name: Generate Lightweight Provenance
        id: provenance
        run: |
          set -euo pipefail
          build_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          # Extract selected tool versions / parameters
          node_ver=$(node --version 2>/dev/null || echo "unknown")
          npm_ver=$(npm --version 2>/dev/null || echo "unknown")
          cyclonedx_ver="3.11.5"
          build_params=$(jq -n --arg url "$TARGET_URL" --arg predVer "${PREDICATE_VERSION}" '{targetUrl:$url,predicateVersion:$predVer}')
          # SLSA-style fields
          build_invocation_id="${GITHUB_RUN_ID}-${PREDICATE_VERSION}"
          # Capture minimal environment / runner context
          runner_env=$(jq -n --arg os "$RUNNER_OS" --arg arch "$RUNNER_ARCH" --arg ref "$GITHUB_REF" --arg sha "$GITHUB_SHA" '{os:$os, arch:$arch, gitRef:$ref, gitSha:$sha}')
          invocation=$(jq -n --argjson params "$build_params" --argjson env "$runner_env" '{parameters:$params, environment:$env}')
          build_config=$(jq -n --arg workflow "$GITHUB_WORKFLOW" --arg job "$GITHUB_JOB" '{workflow:$workflow, job:$job}')
          completeness=$(jq -n '{parameters:true, materials:true, environment:true}')
          jq -n \
            --arg wf "$GITHUB_WORKFLOW" \
            --arg run "$GITHUB_RUN_ID" \
            --arg sha "$GITHUB_SHA" \
            --arg repo "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
            --arg ts "$build_ts" \
            --arg nodev "$node_ver" \
            --arg npmv "$npm_ver" \
            --arg cyclo "$cyclonedx_ver" \
            --argjson params "$build_params" \
            --arg invocationId "$build_invocation_id" \
            --argjson invocation "$invocation" \
            --argjson buildConfig "$build_config" \
            --argjson completeness "$completeness" \
            --argjson runnerEnv "$runner_env" '{
              _type: "https://humanaiconvention.com/attestation/provenance-lite@v1",
              buildType: "workflow/deployed-integrity-check",
              builder: {id: "github-actions", workflow: $wf, runId: $run},
              reproducible: true,
              materials: [{uri: ($repo + ".git"), digest: {sha1: $sha}}],
              metadata: {buildStartedOn: $ts, buildFinishedOn: $ts},
              toolVersions: {node:$nodev, npm:$npmv, cyclonedx:$cyclo},
              parameters: $params,
              invocation: $invocation,
              buildConfig: $buildConfig,
              completeness: $completeness,
              buildInvocationId: $invocationId,
              environment: $runnerEnv
            }' > provenance-lite.json
          if [ -f sbom.min.json ]; then
            sbom_sha=$(sha256sum sbom.min.json | cut -d ' ' -f1)
            jq --arg s "$sbom_sha" '. + {sbomSha256: $s, materials: (.materials + [{uri:"sbom:cyclonedx", digest:{sha256:$s}}])}' provenance-lite.json > prov.tmp && mv prov.tmp provenance-lite.json
          fi
          cat provenance-lite.json
      - name: Cosign Attest Provenance
        id: provenance_attest
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          image_ref='${{ steps.image.outputs.image_ref }}'
          prov_type="https://humanaiconvention.com/attestation/provenance-lite@v1"
          if [ -f .github/schemas/provenance-lite-predicate.schema.json ]; then
            npx --yes ajv-cli@5.0.0 validate -s .github/schemas/provenance-lite-predicate.schema.json -d provenance-lite.json --strict=false
          fi
          ./cosign attest --yes --predicate provenance-lite.json --type "$prov_type" "$image_ref"
          ./cosign verify-attestation --type "$prov_type" "$image_ref" > verify-provenance-attestation.output 2>&1 || true
      - name: Generate & Attest Meta Predicate (aggregate)
        if: matrix.predicate_version == 'v1'
        id: meta_predicate
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          image_ref='${{ steps.image.outputs.image_ref }}'
          image_digest='${{ steps.image.outputs.image_digest }}'
          # Compute predicate digests (if present)
          integ_type="https://humanaiconvention.com/attestation/integrity-report@v1"
          integ_sha=$(sha256sum integrity-report.predicate.json | cut -d ' ' -f1)
          chain_sha=""
          if [ -f fulcio-chain.predicate.json ]; then chain_sha=$(sha256sum fulcio-chain.predicate.json | cut -d ' ' -f1); fi
          sbom_sha=""
          if [ -f sbom.min.json ]; then sbom_sha=$(sha256sum sbom.min.json | cut -d ' ' -f1); fi
          prov_sha=$(sha256sum provenance-lite.json | cut -d ' ' -f1)
          meta_type="https://humanaiconvention.com/attestation/meta-predicate@v1"
          jq -n \
            --arg ts "$ts" \
            --arg img "$image_digest" \
            --arg integ_type "$integ_type" \
            --arg integ_sha "$integ_sha" \
            --arg chain_sha "$chain_sha" \
            --arg sbom_sha "$sbom_sha" \
            --arg prov_sha "$prov_sha" \
            --arg meta_type "$meta_type" '{
              _type: $meta_type,
              predicateVersion: "1.0",
              subject: [{name: "integrity-report-image", digest:{sha256:$img}}],
              timestamp: $ts,
              description: "Aggregate predicate digest index for a single integrity run",
              predicates: [
                {name:"integrity", type:$integ_type, sha256:$integ_sha},
                (if $chain_sha != "" then {name:"fulcio-chain", type:"https://humanaiconvention.com/attestation/fulcio-chain@v1", sha256:$chain_sha} else empty end),
                (if $sbom_sha != "" then {name:"sbom", type:"https://humanaiconvention.com/attestation/sbom@v1", sha256:$sbom_sha} else empty end),
                {name:"provenance-lite", type:"https://humanaiconvention.com/attestation/provenance-lite@v1", sha256:$prov_sha}
              ],
              ordering: ["integrity","fulcio-chain","sbom","provenance-lite"],
              run: {workflow: env.GITHUB_WORKFLOW, runId: env.GITHUB_RUN_ID}
            }' > meta-predicate.json
          if [ -f .github/schemas/meta-predicate.schema.json ]; then
            npx --yes ajv-cli@5.0.0 validate -s .github/schemas/meta-predicate.schema.json -d meta-predicate.json --strict=false
          fi
          ./cosign attest --yes --predicate meta-predicate.json --type "$meta_type" "$image_ref"
          ./cosign verify-attestation --type "$meta_type" "$image_ref" > verify-meta-attestation.output 2>&1 || true
      - name: Enforce Signature Policy (verify all)
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          image_ref='${{ steps.image.outputs.image_ref }}'
          ./cosign verify-blob \
            --certificate integrity-report.json.pem \
            --signature integrity-report.json.sig \
            --certificate-identity-regexp "^https://github.com/${GITHUB_REPOSITORY}/.github/workflows/deployed-integrity-check.yml@refs/heads/main$" \
            --certificate-chain fulcio-chain/fulcio-chain.pem \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            integrity-report.json
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/integrity-report@${PREDICATE_VERSION}" \
            --certificate-identity-regexp "^https://github.com/${GITHUB_REPOSITORY}/.github/workflows/deployed-integrity-check.yml@refs/heads/main$" \
            --certificate-chain fulcio-chain/fulcio-chain.pem \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            "$image_ref" > verify-integrity-attestation.policy 2>&1 || (echo "Integrity attestation verification failed" && exit 1)
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/fulcio-chain@v1" "$image_ref" > verify-chain-attestation.policy 2>&1 || true
          if [ -f sbom.min.json ]; then
            ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/sbom@v1" "$image_ref" > verify-sbom-attestation.policy 2>&1 || true
          fi
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/provenance-lite@v1" "$image_ref" > verify-provenance-attestation.policy 2>&1 || true
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          match=$(jq -r '.match' integrity-report.json || echo false)
          jq -n --arg ts "$ts" --arg match "$match" --arg img "$image_ref" --arg rep '${{ steps.sign.outputs.digest }}' --arg pred '${{ steps.sign.outputs.predicate_digest }}' '{lastAttestationUTC:$ts,match:($match=="true"),image:$img,reportDigest:$rep,predicateDigest:$pred, predicateVersion: env.PREDICATE_VERSION}' > attestation-freshness.json
      - name: Upload Report Artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: deployed-integrity-${{ matrix.predicate_version }}
          path: |
            integrity-report.json
            integrity-report.json.sig
            integrity-report.json.pem
            integrity-report.json.rekor.json
            integrity-report.predicate.json
            verify-attestation.output
            verify-integrity-attestation.policy
            attestation-freshness.json
            fulcio-chain/fulcio-chain.pem
            fulcio-chain/fulcio-chain.pem.sig
            fulcio-chain/fulcio-chain.pem.pem
            fulcio-chain/fulcio-chain.pem.rekor.json
            fulcio-chain.predicate.json
            verify-fulcio-chain-attestation.output
            verify-chain-attestation.policy
            sbom.json
            sbom.min.json
            verify-sbom-attestation.output
            provenance-lite.json
            verify-provenance-attestation.output
            verify-provenance-attestation.policy
            meta-predicate.json
            verify-meta-attestation.output
          retention-days: 7
      - name: Extract Match
        id: result
        run: |
          match=$(jq -r '.match' integrity-report.json || echo 'false')
          echo "match=$match" >> $GITHUB_OUTPUT
      - name: Publish Attestation Freshness Badge (branch)
        if: always() && matrix.predicate_version == 'v1'
        run: |
          set -euo pipefail
          badge_branch=badges
          badge_file=attestation-badge.json
          status_match=$(jq -r '.match' integrity-report.json || echo false)
          label="attestation"
          color="brightgreen"
          if [ "$status_match" != "true" ]; then color="red"; fi
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          message="$( [ "$status_match" = "true" ] && echo ok || echo drift ) @ ${ts}"
          jq -n --arg label "$label" --arg message "$message" --arg color "$color" '{schemaVersion:1,label:$label,message:$message,color:$color}' > $badge_file
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git fetch origin $badge_branch || true
          if git rev-parse --verify origin/$badge_branch >/dev/null 2>&1; then
            git checkout $badge_branch || git checkout -b $badge_branch origin/$badge_branch
          else
            git checkout -b $badge_branch
          fi
          mv ../$badge_file $badge_file 2>/dev/null || true
          cp $GITHUB_WORKSPACE/$badge_file $badge_file || true
          git add $badge_file
          if git diff --cached --quiet; then
            echo "No badge changes to commit"; exit 0; fi
          git commit -m "chore(badge): update attestation badge $ts" || true
          git push origin $badge_branch
      - name: Log Attestation Transparency Entry
        if: matrix.predicate_version == 'v1'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="$GITHUB_REPOSITORY"
          att_issue_title="Integrity Attestations Log"
          report_digest='${{ steps.sign.outputs.digest }}'
          predicate_digest='${{ steps.sign.outputs.predicate_digest }}'
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/labels/integrity-attestation" | jq -e '.name' >/dev/null 2>&1 || \
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
              -d '{"name":"integrity-attestation","color":"0e8a16","description":"Log of integrity report attestations"}' \
              "https://api.github.com/repos/$repo/labels" >/dev/null 2>&1 || true
          existing=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/issues?state=open&labels=integrity-attestation" | jq -r '.[0].number // empty')
          drift_match=$(jq -r '.match' integrity-report.json 2>/dev/null || echo false)
          entry="- ${ts} reportSha256=${report_digest} predicateSha256=${predicate_digest} run=${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID} driftMatch=${drift_match}"
          if [ -n "$existing" ]; then
            payload=$(jq -n --arg b "$entry" '{body:$b}')
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$payload" "https://api.github.com/repos/$repo/issues/$existing/comments" >/dev/null
          else
            body="Integrity attestation log. Each comment line records a signed integrity report + predicate pair.\n\n$entry"
            payload=$(jq -n --arg t "$att_issue_title" --arg b "$body" '{title:$t, body:$b, labels:["integrity-attestation"]}')
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$payload" "https://api.github.com/repos/$repo/issues" >/dev/null
          fi
      - name: Open / Update Drift Issue
        if: matrix.predicate_version == 'v1' && steps.result.outputs.match != 'true'
        id: drift_issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          digest='${{ steps.sign.outputs.digest }}'
          predicate_digest='${{ steps.sign.outputs.predicate_digest }}'
          set -euo pipefail
          repo="$GITHUB_REPOSITORY"
            title="Deployed Integrity Drift Detected"
            remote=$(jq -r '.remoteSha256 // "null"' integrity-report.json)
            baseline=$(jq -r '.baselineSha256 // "null"' integrity-report.json)
            url=$(jq -r '.url' integrity-report.json)
            error=$(jq -r '.error // empty' integrity-report.json)
            ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            body="An integrity drift was detected.\n\n- Time (UTC): ${ts}\n- URL: ${url}\n- Baseline SHA256: ${baseline}\n- Remote SHA256: ${remote}\n- Integrity Report Digest (sha256): ${digest}\n- Predicate Digest (sha256): ${predicate_digest}\n- Error: ${error:-none}\n- Workflow Run: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/labels/integrity-drift" | jq -e '.name' >/dev/null 2>&1 || \
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
              -d '{"name":"integrity-drift","color":"d93f0b","description":"Automated integrity drift detection"}' \
              "https://api.github.com/repos/$repo/labels" >/dev/null 2>&1 || true
          existing=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/issues?state=open&labels=integrity-drift" | jq -r '.[0].number // empty')
          if [ -n "$existing" ]; then
            comment_payload=$(jq -n --arg msg "Drift re-detected at ${ts}. Remote=${remote} Baseline=${baseline} ReportDigest=${digest} PredicateDigest=${predicate_digest} Error=${error:-none}" '{body:$msg}')
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$comment_payload" "https://api.github.com/repos/$repo/issues/$existing/comments" >/dev/null
            echo "number=$existing" >> $GITHUB_OUTPUT
          else
            issue_payload=$(jq -n --arg t "$title" --arg b "$body" '{title:$t, body:$b, labels:["integrity-drift"]}')
            create_resp=$(mktemp)
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$issue_payload" "https://api.github.com/repos/$repo/issues" > "$create_resp"
            number=$(jq -r '.number' "$create_resp")
            echo "number=$number" >> $GITHUB_OUTPUT
          fi
      - name: Close Drift Issue (if resolved)
        if: matrix.predicate_version == 'v1' && steps.result.outputs.match == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo="$GITHUB_REPOSITORY"
          existing=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/issues?state=open&labels=integrity-drift" | jq -r '.[0].number // empty')
          if [ -n "$existing" ]; then
            close_payload=$(jq -n '{state:"closed"}')
            curl -s -X PATCH -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$close_payload" "https://api.github.com/repos/$repo/issues/$existing" >/dev/null || true
          fi
      - name: Summary
        if: always() && matrix.predicate_version == 'v1'
        run: |
          echo "## Deployed Integrity Check (multi-version)" >> $GITHUB_STEP_SUMMARY
          jq -r '. | "URL: " + .url + "\nMatch: " + (.match|tostring) + "\nBaseline: " + (.baselineSha256 // "null") + "\nRemote: " + (.remoteSha256 // "null") + "\nElapsed(ms): " + (.elapsedMs|tostring)' integrity-report.json >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.result.outputs.match }}" != "true" ]; then
            echo "\nDrift detected (see issues labeled integrity-drift)" >> $GITHUB_STEP_SUMMARY
          else
            echo "\nNo drift detected" >> $GITHUB_STEP_SUMMARY
          fi
  policy-gate:
    name: Predicate Version Policy Gate
    needs: integrity
    runs-on: ubuntu-latest
    env:
      CUTOFF_ENFORCE_V2: '2025-11-01' # date after which v2 MUST exist
      DEPRECATE_V1_AFTER: '2026-02-01' # date after which v1 MUST be absent
    steps:
      - name: Evaluate Predicate Set
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          today=$(date -u +%Y-%m-%d)
          echo "Today: $today"
          echo "Cutover (require v2): $CUTOFF_ENFORCE_V2"
            echo "Deprecate v1 after: $DEPRECATE_V1_AFTER"
          repo=${GITHUB_REPOSITORY}
          run_id=${GITHUB_RUN_ID}
          artifacts_json=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/actions/runs/$run_id/artifacts")
          has_v1=$(echo "$artifacts_json" | jq -r '.artifacts[]?.name' | grep -E '^deployed-integrity-v1$' || true)
          has_v2=$(echo "$artifacts_json" | jq -r '.artifacts[]?.name' | grep -E '^deployed-integrity-v2$' || true)
          echo "Detected artifacts: $(echo "$artifacts_json" | jq -r '.artifacts[]?.name' | tr '\n' ' ')"
          require_v2=false
          forbid_v1=false
          if [[ "$today" > "$CUTOFF_ENFORCE_V2" || "$today" == "$CUTOFF_ENFORCE_V2" ]]; then require_v2=true; fi
          if [[ "$today" > "$DEPRECATE_V1_AFTER" || "$today" == "$DEPRECATE_V1_AFTER" ]]; then forbid_v1=true; fi
          echo "Policy require_v2=$require_v2 forbid_v1=$forbid_v1"
          if [ "$require_v2" = true ] && [ -z "$has_v2" ]; then
            echo "::error::Predicate v2 artifact missing after cutover date $CUTOFF_ENFORCE_V2"; exit 12; fi
          if [ "$forbid_v1" = true ] && [ -n "$has_v1" ]; then
            echo "::error::Predicate v1 artifact still present after deprecation date $DEPRECATE_V1_AFTER"; exit 13; fi
          if [ "$require_v2" = false ] && [ -z "$has_v2" ]; then
            echo "::warning::v2 not yet emitted (pre-cutover)."; fi
          if [ "$forbid_v1" = false ] && [ -n "$has_v1" ]; then
            echo "::notice::v1 still emitted (allowed pre-deprecation)."; fi
          if [ "$forbid_v1" = false ] && [ -z "$has_v1" ]; then
            echo "::warning::v1 already absent pre-deprecation (ensure consumer readiness)."; fi
          echo "Policy gate passed."
