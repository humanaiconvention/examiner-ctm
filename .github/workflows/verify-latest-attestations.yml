name: Verify Latest Attestations (Out-of-Band)
on:
  workflow_dispatch:
    inputs:
      forceRunId:
        description: "Optional run ID to verify instead of latest successful integrity run"
        required: false
      imageVersion:
        description: "Predicate version to focus on (v1|v2|all)"
        required: false
        default: all
  schedule:
    - cron: '37 */6 * * *' # every 6 hours slightly offset

permissions:
  contents: read
  packages: read
  id-token: write
  issues: write

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      target_run: ${{ steps.find.outputs.run_id }}
    steps:
      - name: Resolve Target Run
        id: find
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.forceRunId }}" ]; then
            echo "Using forced run id: ${{ github.event.inputs.forceRunId }}"
            echo "run_id=${{ github.event.inputs.forceRunId }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Query latest successful integrity workflow run (main branch)
          repo=${GITHUB_REPOSITORY}
          wf_file=deployed-integrity-check.yml
          runs=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/actions/workflows/$wf_file/runs?branch=main&status=success&per_page=5")
          run_id=$(echo "$runs" | jq -r '.workflow_runs[0].id // empty')
          if [ -z "$run_id" ]; then echo "::error::No successful integrity runs found"; exit 1; fi
          echo "Found latest successful run: $run_id"
          echo "run_id=$run_id" >> $GITHUB_OUTPUT

  verify:
    needs: discover
    runs-on: ubuntu-latest
    env:
      COSIGN_VERSION: v2.4.0
      IMAGE_VERSION: ${{ github.event.inputs.imageVersion || 'all' }}
    steps:
      - name: Setup Cosign
        run: |
          set -euo pipefail
          curl -sSL -o cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
          chmod +x cosign
          ./cosign version || true
      - name: Checkout (for schemas)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Setup Node (for ajv)
        uses: actions/setup-node@a0853c24544627f65ddf259abe73b1d18a591444 # v5.0.0
        with:
          node-version: '20'
      - name: Fetch Artifacts Metadata
        id: artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo=${GITHUB_REPOSITORY}
          run_id='${{ needs.discover.outputs.target_run }}'
          echo "Inspecting artifacts for run $run_id"
          artifacts_json=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/actions/runs/$run_id/artifacts")
          echo "$artifacts_json" > artifacts.json
          names=$(echo "$artifacts_json" | jq -r '.artifacts[].name')
          echo "Artifact names:\n$names"
          echo "names<<EOF" >> $GITHUB_OUTPUT
          echo "$names" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Download Integrity Artifacts (v1 & v2)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          run_id='${{ needs.discover.outputs.target_run }}'
          repo=${GITHUB_REPOSITORY}
          dl() { aid=$1; name=$2; curl -L -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/actions/artifacts/$aid/zip" -o "$name.zip" && unzip -q "$name.zip" -d "$name"; }
          for want in deployed-integrity-v1 deployed-integrity-v2; do
            id=$(jq -r --arg n "$want" '.artifacts[] | select(.name==$n) | .id' artifacts.json)
            if [ -n "$id" ] && [ "$id" != "null" ]; then
              echo "Downloading $want (id=$id)"; dl "$id" "$want" || echo "Failed to download $want";
            else
              echo "Missing artifact $want (expected if deprecation advanced).";
            fi
          done
      - name: Determine Image References
        id: images
        run: |
          set -euo pipefail
          # Parse attestation-freshness.json for image ref (present in both artifacts with same value)
          ref_v1=$(jq -r '.image // empty' deployed-integrity-v1/attestation-freshness.json 2>/dev/null || true)
          ref_v2=$(jq -r '.image // empty' deployed-integrity-v2/attestation-freshness.json 2>/dev/null || true)
          # Prefer v2 if present, else v1
          final_ref="$ref_v2"
          if [ -z "$final_ref" ]; then final_ref="$ref_v1"; fi
          if [ -z "$final_ref" ]; then echo "::error::No image reference found"; exit 1; fi
          echo "image_ref=$final_ref" >> $GITHUB_OUTPUT
      - name: Verify Integrity Predicates
        run: |
          set -euo pipefail
          image_ref='${{ steps.images.outputs.image_ref }}'
          mode='${{ env.IMAGE_VERSION }}'
          verify_one() {
            ver=$1; field=$2
            echo "Verifying integrity predicate $ver"
            ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/integrity-report@${ver}" \
              --certificate-identity-regexp "^https://github.com/${GITHUB_REPOSITORY}/.github/workflows/deployed-integrity-check.yml@refs/heads/main$" \
              --certificate-oidc-issuer https://token.actions.githubusercontent.com \
              "$image_ref" | jq -r --arg f "$field" 'select(.payloadType)|.payload|@base64d|fromjson|.predicate|getpath($f|split("."))' || echo "(warning) verification or jq extract failed for $ver"
          }
          if [ "$mode" = 'all' ] || [ "$mode" = 'v1' ]; then
            verify_one v1 reportFields.match
          fi
          if [ "$mode" = 'all' ] || [ "$mode" = 'v2' ]; then
            verify_one v2 report.status
          fi
      - name: Verify SBOM Attestation
        run: |
          set -euo pipefail
          image_ref='${{ steps.images.outputs.image_ref }}'
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/sbom@v1" "$image_ref" > sbom.att 2>&1 || echo "SBOM attestation not present"
      - name: Verify Provenance Attestation
        run: |
          set -euo pipefail
          image_ref='${{ steps.images.outputs.image_ref }}'
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/provenance-lite@v1" "$image_ref" > provenance.att 2>&1 || echo "Provenance attestation not present"
      - name: Verify Fulcio Chain Attestation
        run: |
          set -euo pipefail
          image_ref='${{ steps.images.outputs.image_ref }}'
            ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/fulcio-chain@v1" "$image_ref" > chain.att 2>&1 || echo "Chain attestation not present"
      - name: Verify Meta Predicate Attestation
        run: |
          set -euo pipefail
          image_ref='${{ steps.images.outputs.image_ref }}'
          ./cosign verify-attestation --type "https://humanaiconvention.com/attestation/meta-predicate@v1" "$image_ref" > meta.att 2>&1 || echo "Meta predicate attestation not present (expected only for v1 lane)"
      - name: Schema Validate & Summarize JSON
        id: schema_validate
        run: |
          set -euo pipefail
          summary_json=verification-summary.json
          run_id='${{ needs.discover.outputs.target_run }}'
          image_ref='${{ steps.images.outputs.image_ref }}'
          image_digest=${image_ref#*@}
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          all_schema_ok=true
          meta_consistent=true
          validate() {
            file=$1; schema=$2; name=$3; var_prefix=$4
            present=false; valid=false
            if [ -f "$file" ]; then
              present=true
              if [ -f "$schema" ]; then
                if npx --yes ajv-cli@5.0.0 validate -s "$schema" -d "$file" --strict=false >/dev/null 2>&1; then
                  valid=true
                else
                  all_schema_ok=false
                fi
              else
                echo "Schema $schema missing for $file" >&2
                all_schema_ok=false
              fi
            fi
            printf '%s_present=%s\n' "$var_prefix" "$present" >> vars.out
            printf '%s_schemaValid=%s\n' "$var_prefix" "$valid" >> vars.out
          }
          : > vars.out
          validate deployed-integrity-v1/integrity-report.predicate.json .github/schemas/integrity-report-predicate.schema.json integrity_v1 integ_v1
          validate deployed-integrity-v2/integrity-report.predicate.json .github/schemas/integrity-report-predicate.v2.schema.json integrity_v2 integ_v2
          validate deployed-integrity-v1/fulcio-chain.predicate.json .github/schemas/fulcio-chain-predicate.schema.json chain chain
          validate deployed-integrity-v1/provenance-lite.json .github/schemas/provenance-lite-predicate.schema.json provenance provenance
          validate deployed-integrity-v1/meta-predicate.json .github/schemas/meta-predicate.schema.json meta meta
          # SBOM: locate file (prefer v2 artifact if exists) and validate against minimal schema
          sbom_file=""
          if [ -f deployed-integrity-v2/sbom.min.json ]; then sbom_file="deployed-integrity-v2/sbom.min.json"; elif [ -f deployed-integrity-v1/sbom.min.json ]; then sbom_file="deployed-integrity-v1/sbom.min.json"; fi
          sbom_present=false
          sbom_schemaValid=false
          if [ -n "$sbom_file" ]; then
            sbom_present=true
            if npx --yes ajv-cli@5.0.0 validate -s .github/schemas/sbom-min.schema.json -d "$sbom_file" --strict=false >/dev/null 2>&1; then
              sbom_schemaValid=true
            else
              all_schema_ok=false
            fi
          fi
          printf 'sbom_present=%s\n' "$sbom_present" >> vars.out
          printf 'sbom_schemaValid=%s\n' "$sbom_schemaValid" >> vars.out
          # Extract fields
          match_v1=null
          if [ -f deployed-integrity-v1/integrity-report.predicate.json ]; then match_v1=$(jq -r '.reportFields.match // empty' deployed-integrity-v1/integrity-report.predicate.json); fi
          status_v2=null
          if [ -f deployed-integrity-v2/integrity-report.predicate.json ]; then status_v2=$(jq -r '.report.status // empty' deployed-integrity-v2/integrity-report.predicate.json); fi
          prov_has_sbom=false
          if [ -f deployed-integrity-v1/provenance-lite.json ]; then
            jq -e '.sbomSha256' deployed-integrity-v1/provenance-lite.json >/dev/null 2>&1 && prov_has_sbom=true || true
          fi
          # Digests
          sha_or_empty() { [ -f "$1" ] && sha256sum "$1" | cut -d ' ' -f1 || echo ""; }
          integ_v1_sha=$(sha_or_empty deployed-integrity-v1/integrity-report.predicate.json)
          integ_v2_sha=$(sha_or_empty deployed-integrity-v2/integrity-report.predicate.json)
          chain_sha=$(sha_or_empty deployed-integrity-v1/fulcio-chain.predicate.json)
          sbom_sha=""; if [ -f deployed-integrity-v1/sbom.min.json ]; then sbom_sha=$(sha_or_empty deployed-integrity-v1/sbom.min.json); elif [ -f deployed-integrity-v2/sbom.min.json ]; then sbom_sha=$(sha_or_empty deployed-integrity-v2/sbom.min.json); fi
          prov_sha=$(sha_or_empty deployed-integrity-v1/provenance-lite.json)
          meta_sha=$(sha_or_empty deployed-integrity-v1/meta-predicate.json)
          meta_refs={}
          if [ -f deployed-integrity-v1/meta-predicate.json ]; then
            meta_refs=$(jq -r '[.predicates[] | {(.name): .sha256}] | add' deployed-integrity-v1/meta-predicate.json)
            # Cross-check each referenced digest against actual computed digests
            ref_integ=$(jq -r '.predicates[]|select(.name=="integrity")|.sha256' deployed-integrity-v1/meta-predicate.json 2>/dev/null || echo "")
            if [ -n "$ref_integ" ] && [ -n "$integ_v1_sha" ] && [ "$ref_integ" != "$integ_v1_sha" ]; then meta_consistent=false; fi
            ref_chain=$(jq -r '.predicates[]|select(.name=="fulcio-chain")|.sha256' deployed-integrity-v1/meta-predicate.json 2>/dev/null || echo "")
            if [ -n "$ref_chain" ] && [ -n "$chain_sha" ] && [ "$ref_chain" != "$chain_sha" ]; then meta_consistent=false; fi
            ref_sbom=$(jq -r '.predicates[]|select(.name=="sbom")|.sha256' deployed-integrity-v1/meta-predicate.json 2>/dev/null || echo "")
            if [ -n "$ref_sbom" ] && [ -n "$sbom_sha" ] && [ "$ref_sbom" != "$sbom_sha" ]; then meta_consistent=false; fi
            ref_prov=$(jq -r '.predicates[]|select(.name=="provenance-lite")|.sha256' deployed-integrity-v1/meta-predicate.json 2>/dev/null || echo "")
            if [ -n "$ref_prov" ] && [ -n "$prov_sha" ] && [ "$ref_prov" != "$prov_sha" ]; then meta_consistent=false; fi
          fi
          # Read schema validation vars
          . vars.out
          jq -n \
            --arg runId "$run_id" \
            --arg image "$image_ref" \
            --arg imageDigest "$image_digest" \
            --arg ts "$ts" \
            --argjson metaRefs "$meta_refs" \
            --arg allSchemaOk "$all_schema_ok" \
            --arg metaConsistent "$meta_consistent" \
            --arg integV1Present "$integ_v1_present" --arg integV1Valid "$integ_v1_schemaValid" \
            --arg integV2Present "$integ_v2_present" --arg integV2Valid "$integ_v2_schemaValid" \
            --arg chainPresent "$chain_present" --arg chainValid "$chain_schemaValid" \
            --arg provPresent "$provenance_present" --arg provValid "$provenance_schemaValid" \
            --arg metaPresent "$meta_present" --arg metaValid "$meta_schemaValid" \
            --arg sbomPresent "$sbom_present" --arg sbomValid "$sbom_schemaValid" \
            --arg integV1Sha "$integ_v1_sha" --arg integV2Sha "$integ_v2_sha" --arg chainSha "$chain_sha" --arg sbomSha "$sbom_sha" --arg provSha "$prov_sha" --arg metaSha "$meta_sha" \
            --arg matchV1 "$match_v1" --arg statusV2 "$status_v2" --arg provSbom "$prov_has_sbom" \
            '{runId:$runId,image:$image,imageDigest:$imageDigest,timestamp:$ts,overall:{allSchemaValid:($allSchemaOk=="true"),metaConsistent:($metaConsistent=="true")},predicates:{integrity_v1:{present:($integV1Present=="true"),schemaValid:($integV1Valid=="true"),match:($matchV1|if .=="null" or .=="" then null else (.|test("^true$") ) end),sha256:$integV1Sha},integrity_v2:{present:($integV2Present=="true"),schemaValid:($integV2Valid=="true"),status:($statusV2|if .=="null" or .=="" then null else (.|test("^true$") ) end),sha256:$integV2Sha},chain:{present:($chainPresent=="true"),schemaValid:($chainValid=="true"),sha256:$chainSha},sbom:{present:($sbomPresent=="true"),schemaValid:($sbomValid=="true"),sha256:$sbomSha},provenance:{present:($provPresent=="true"),schemaValid:($provValid=="true"),hasSbomLink:($provSbom=="true"),sha256:$provSha},meta:{present:($metaPresent=="true"),schemaValid:($metaValid=="true"),sha256:$metaSha, references:$metaRefs}}}' > "$summary_json"
          cat "$summary_json"
          echo "summary_path=$summary_json" >> $GITHUB_OUTPUT
      - name: Upload Verification Summary Artifact
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: verification-summary
          path: verification-summary.json
          retention-days: 14
      - name: Summarize
        run: |
          set -euo pipefail
          echo "## Out-of-Band Attestation Verification" >> $GITHUB_STEP_SUMMARY
          echo "Image: ${{ steps.images.outputs.image_ref }}" >> $GITHUB_STEP_SUMMARY
          ls -1 deployed-integrity-v1 2>/dev/null || true
          ls -1 deployed-integrity-v2 2>/dev/null || true
          echo '\nArtifacts present:' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.artifacts.outputs.names }}' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo '\nIntegrity Predicate Results:' >> $GITHUB_STEP_SUMMARY
          echo '- v1:' >> $GITHUB_STEP_SUMMARY
          grep -q match deployed-integrity-v1/integrity-report.predicate.json 2>/dev/null && jq -r '.reportFields.match' deployed-integrity-v1/integrity-report.predicate.json 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo '  (missing)' >> $GITHUB_STEP_SUMMARY
          echo '- v2:' >> $GITHUB_STEP_SUMMARY
          grep -q report deployed-integrity-v2/integrity-report.predicate.json 2>/dev/null && jq -r '.report.status' deployed-integrity-v2/integrity-report.predicate.json 2>/dev/null >> $GITHUB_STEP_SUMMARY || echo '  (missing)' >> $GITHUB_STEP_SUMMARY
          echo '\nCompleted.' >> $GITHUB_STEP_SUMMARY
          if [ -f verification-summary.json ]; then
            echo '\nSchema Validation:' >> $GITHUB_STEP_SUMMARY
            jq -r '.overall' verification-summary.json >> $GITHUB_STEP_SUMMARY || true
          fi
      - name: Record Verification Log Issue
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          repo=${GITHUB_REPOSITORY}
          title="Out-of-Band Verification Log"
          label="verification-log"
          # ensure label
          curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/labels/$label" | jq -e '.name' >/dev/null 2>&1 || \
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
              -d '{"name":"'"$label"'","color":"0366d6","description":"Log of out-of-band attestation verification runs"}' \
              "https://api.github.com/repos/$repo/labels" >/dev/null 2>&1 || true
          issue_num=$(curl -s -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$repo/issues?state=open&labels=$label" | jq -r '.[0].number // empty')
          line_ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          if [ -f verification-summary.json ]; then
            integ_v1=$(jq -r '.predicates.integrity_v1.present as $p | .predicates.integrity_v1.match as $m | "integ_v1=" + ($p|tostring) + "(match=" + ($m|tostring)+")"' verification-summary.json)
            integ_v2=$(jq -r '.predicates.integrity_v2.present as $p | .predicates.integrity_v2.status as $s | "integ_v2=" + ($p|tostring) + "(status=" + ($s|tostring)+")"' verification-summary.json)
            chain_p=$(jq -r '.predicates.chain.present' verification-summary.json)
            prov_p=$(jq -r '.predicates.provenance.present' verification-summary.json)
            meta_p=$(jq -r '.predicates.meta.present' verification-summary.json)
            sbom_p=$(jq -r '.predicates.sbom.present' verification-summary.json)
            sbom_valid=$(jq -r '.predicates.sbom.schemaValid // false' verification-summary.json)
            schema_ok=$(jq -r '.overall.allSchemaValid' verification-summary.json)
            meta_consistent=$(jq -r '.overall.metaConsistent' verification-summary.json)
          else
            integ_v1="integ_v1=unknown"; integ_v2="integ_v2=unknown"; chain_p=false; prov_p=false; meta_p=false; sbom_p=false; sbom_valid=false; schema_ok=false; meta_consistent=false
          fi
          entry="- ${line_ts} run=${{ needs.discover.outputs.target_run }} image=${{ steps.images.outputs.image_ref }} ${integ_v1} ${integ_v2} chain=${chain_p} provenance=${prov_p} sbom=${sbom_p}(valid=${sbom_valid}) meta=${meta_p} schemaValid=${schema_ok} metaConsistent=${meta_consistent}"
          if [ -n "$issue_num" ]; then
            payload=$(jq -n --arg b "$entry" '{body:$b}')
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$payload" "https://api.github.com/repos/$repo/issues/$issue_num/comments" >/dev/null
          else
            body="Out-of-band verification log. Each comment line records a verification pass against latest integrity run.\n\n$entry"
            payload=$(jq -n --arg t "$title" --arg b "$body" '{title:$t, body:$b, labels:["'"$label"'"]}')
            curl -s -X POST -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -d "$payload" "https://api.github.com/repos/$repo/issues" >/dev/null
          fi
      - name: Publish Verification Badge & Trend
        if: always()
        run: |
          set -euo pipefail
          badge_branch=badges
          badge_file=verification-badge.json
          csv_file=verification-trend.csv
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          pass=false
          schema_ok=false
          meta_consistent=false
          if [ -f verification-summary.json ]; then
            schema_ok=$(jq -r '.overall.allSchemaValid' verification-summary.json)
            meta_consistent=$(jq -r '.overall.metaConsistent' verification-summary.json)
          fi
          if [ "$schema_ok" = "true" ] && [ "$meta_consistent" = "true" ]; then pass=true; fi
          color=red; message="fail"; if [ "$pass" = true ]; then color=brightgreen; message="ok"; fi
          jq -n --arg label "verification" --arg message "$message" --arg color "$color" '{schemaVersion:1,label:$label,message:$message,color:$color}' > $badge_file
          # Prepare CSV line
          run_id='${{ needs.discover.outputs.target_run }}'
          image='${{ steps.images.outputs.image_ref }}'
          integ_v1_present=$(jq -r '.predicates.integrity_v1.present' verification-summary.json 2>/dev/null || echo "")
          integ_v2_present=$(jq -r '.predicates.integrity_v2.present' verification-summary.json 2>/dev/null || echo "")
          sbom_present=$(jq -r '.predicates.sbom.present' verification-summary.json 2>/dev/null || echo "")
          sbom_valid=$(jq -r '.predicates.sbom.schemaValid' verification-summary.json 2>/dev/null || echo "")
          if [ -f $csv_file ]; then
            header_first=$(head -n1 $csv_file || echo "")
            if ! echo "$header_first" | grep -q 'sbomPresent'; then
              tmp_csv=${csv_file}.tmp
              echo "timestamp,runId,image,schemaValid,metaConsistent,integV1Present,integV2Present,sbomPresent,sbomSchemaValid" > $tmp_csv
              tail -n +2 $csv_file | while IFS=, read -r c_ts c_run c_img c_schema c_meta c_v1 c_v2; do
                echo "$c_ts,$c_run,$c_img,$c_schema,$c_meta,$c_v1,$c_v2,," >> $tmp_csv
              done
              mv $tmp_csv $csv_file
            fi
          fi
          if [ ! -f $csv_file ]; then echo "timestamp,runId,image,schemaValid,metaConsistent,integV1Present,integV2Present,sbomPresent,sbomSchemaValid" > $csv_file; fi
          echo "$ts,$run_id,$image,$schema_ok,$meta_consistent,$integ_v1_present,$integ_v2_present,$sbom_present,$sbom_valid" >> $csv_file
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git fetch origin $badge_branch || true
          if git rev-parse --verify origin/$badge_branch >/dev/null 2>&1; then
            git checkout $badge_branch || git checkout -b $badge_branch origin/$badge_branch
          else
            git checkout -b $badge_branch
          fi
          mv ../$badge_file $badge_file 2>/dev/null || true
          mv ../$csv_file $csv_file 2>/dev/null || true
          cp $GITHUB_WORKSPACE/$badge_file $badge_file || true
          cp $GITHUB_WORKSPACE/$csv_file $csv_file || true
          git add $badge_file $csv_file
          if git diff --cached --quiet; then echo "No verification badge/trend changes"; exit 0; fi
          git commit -m "chore(verification): update badge & trend $ts" || true
          git push origin $badge_branch